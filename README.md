
### 什么是DDD领域驱动设计模式？
领域驱动设计（Domain-Driven Design, DDD）是一种旨在解决复杂业务需求的软件架构方法。该方法采用分而治之的策略，通过详细地分析业务领域、建立精确的模型，并据此指导微服务的实现，以便更有效地应对业务的复杂性并提升系统的可维护性。DDD的核心流程可分为两大部分：战略设计和战术实施。战略设计涉及业务流程的深入理解、业务领域的划分、模型的构建以及服务的抽象；而战术实施则涉及将这些领域的概念转换为具体的、可执行的服务代码。

在Go语言的微服务架构中，DDD可以通过以下四个层次的结构来实现：接口层（负责与外界交互）、应用层（处理参数校验、处理顶层业务逻辑）、领域层（包含实体、值对象、聚合根、业务领域模型）、基础设施层（提供技术支持如数据库访问）。在实施DDD时，要特别留心避免一些常见的反模式，例如忽视对业务的深入分析、过度设计以及不合理的上下文界限划分等问题。

DDD领域设计模式需要开发人员熟练掌握其思想，对业务模型足够熟悉，但是很多情况下，我们在开发项目时所面对的业务都是未知的，随着时间的变更，业务不断的变更迭代，如果要完全遵循DDD理念进行设计在团队项目中得保证每个成员都和你一样具有同等的开发、业务理解能力，这显然是不太可能的。

### 没有完美的DDD设计模式
实际上并没有100%理想的DDD设计模式， 过度的遵循DDD领域驱动设计模式只要让项目显得跟花里胡哨，性能会成为设计模式的牺牲品，最简单的例子就是 req->vo->ent->po->ent->vo->reply。每一层的转换都需要转换具体的操作对象，单个对象还好，遇到请求列表的时候，这简直就是灾难，相信你在很多的DDD示例中也看见过很多在获取数据后，通过for遍历转换对象的操作吧。

在后续的目录规划上，并不是100%遵循DDD领域驱动理念进行设计的，为了减少复杂度、减少性能牺牲而去破坏了一些理论完整性，但是我会在后面的规划中详细描述为什么要这么做，这么做的好处是什么。


### 目录概览
```
├── api # 接口层
│   └── layout # layot服务定义
│       ├── dictionary # 应用定义。
│       │   └── v1
│       └── errors # 系统全局error
├── cmd # 入口
│   └── server 
├── internal
│   ├── app # 应用层
│   ├── conf # 配置文件 
│   ├── domain # 领域层
│   │   ├── entity # 实体
│   │   ├── repository # 仓储接口
│   │   └── service # 领域服务
│   ├── infra # 基础设施层
│   │   ├── dbs # 数据库基础设施
│   │   ├── mqs # 消息队列基础设施
│   │   └── rds # 缓存基础设施
│   └── types # 值对象
├── static # 静态文件
├── third_party # 三方proto
└── tmp # 临时日志文件
```

#### api目录
api目录相当于DDD中的接口层，我们在proto中可以直接定义请求参数、返回参数、接口等，并生成service\client。api目录下并不是直接就存放当前系统的proto,而是增加了一层目录结构进行存放，这样的好处时我们可以将当前系统的proto单独抽出去作为大仓模式，也可以引入额外三方的服务的proto生成对应的client代码。
```
├── api # 接口层
│   └── layout # layot服务定义
│       ├── dictionary # 应用定义。
│       │   └── v1
│       └── errors # 系统全局error
│   └── ... # 其他服务
```

#### cmd目录
cmd 目录是启动目录，里面主要是实现了配置的初始化和变更监听，完成了将应用层注册到接口层中。

#### internal目录
internal目录主要存放不让第三方服务访问的代码，比如我当前项目的配置文件、我当前服务的具体业务逻辑等。

##### internal/conf
主要负责整个内部系统的配置文件，和kratos不一样的是，我采用的是结构体直接定义，而不是使用protoc定义，这样在很大程度上，会更加方便在开发的过程中进行使用。
另外需要注意的是conf定义在internal内是为了防止第三方服务在引用当前服务时，调用到其配置文件。

##### internal/app
app目录充当着系统的应用层，主要负责协议转换（DTO）、权限校验、以及领域编排等。应用层不应该包含业务逻辑，而是进入核心业务逻辑之前的一些准入工作，以及核心逻辑处理完成之后的收尾。


##### internal/domain 目录
领域服务核心能力，提供业务逻辑实现（比如赤字数据生成读取、报表下载、GMV 等)，核心要素包括领域服务 service 、领域实体 entity、仓储接口 repository。其中业务缓存、分布式锁、发送通知等，尽量可以收敛到领域服务之中。


#### internal/infra
实现仓储接口，RPC 具体实现、DB 存储、缓存、消息中间件等，都会去实现领域层定义好的仓储接口。


#### internal/pkg
主要负责内部系统的一些方法包封装，这里放到internal下时为了防止外部调用。

#### static
主要存放系统的一些静态资源文件

#### third_party
主要存放三方的protoc文件

#### tmp
主要存放临时文件，如日志等


#### 其他说明
在这里我像特地说明一下关于服务根据不同的应用领域进行分类的问题，在kratos的官网示例beer-shop中，根据用户端、管理端将对领域又进行了分类为admin/interface...
admin/interface/..分成了不同的服务进行启动。但是其实无论时管理端还是用户端，在日常的开发中，我们并不会对其进行拆分成多个服务进行运行，因为他们本身就属于同一个领域中，这样太过于细致的划分，会导致服务的数量增加，也增加了维护成本。其次时进行划分会重复定义biz和data，一个数据表的抽象数据结构需要在每个端都定义一遍，也不是一个明智的选择。
在这里其实我更加主张在通过service中进行实现。我们可以通过接口来进行区分不同的请求端，比如管理端可以用过/admin/xxx 客户端可以通过/client/xxx 这样在配置网关的使用可以通过网关进行较好的接口鉴权。
